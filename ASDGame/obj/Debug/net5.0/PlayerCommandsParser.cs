//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\arnold\source\repos\Test\Test\InputHandling\Antlr\Grammar\PlayerCommands.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace InputHandling.Antlr.Grammar {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class PlayerCommandsParser : Parser {
	public const int
		SPACE=1, MOVE=2, WALK=3, GO=4, ATTACK=5, SLASH=6, STRIKE=7, PICKUP=8, 
		GET=9, DROP=10, EXIT=11, LEAVE=12, SAY=13, SHOUT=14, REPLACE=15, PAUSE=16, 
		RESUME=17, CREATE_SESSION=18, JOIN_SESSION=19, REQUEST_SESSIONS=20, START_SESSION=21, 
		FORWARD=22, UP=23, NORTH=24, BACKWARD=25, DOWN=26, SOUTH=27, LEFT=28, 
		WEST=29, RIGHT=30, EAST=31, NUMBER=32, MESSAGE=33;
	public const int
		RULE_input = 0, RULE_step = 1, RULE_message = 2, RULE_command = 3, RULE_forward = 4, 
		RULE_backward = 5, RULE_left = 6, RULE_right = 7, RULE_direction = 8;
	public static readonly string[] ruleNames = {
		"input", "step", "message", "command", "forward", "backward", "left", 
		"right", "direction"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'move'", "'walk'", "'go'", "'attack'", "'slash'", "'strike'", 
		"'pickup'", "'get'", "'drop'", "'exit'", "'leave'", "'say'", "'shout'", 
		"'replace'", "'pause'", "'resume'", "'create_session'", "'join_session'", 
		"'request_sessions'", "'start_session'", "'forward'", "'up'", "'north'", 
		"'backward'", "'down'", "'south'", "'left'", "'west'", "'right'", "'east'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "SPACE", "MOVE", "WALK", "GO", "ATTACK", "SLASH", "STRIKE", "PICKUP", 
		"GET", "DROP", "EXIT", "LEAVE", "SAY", "SHOUT", "REPLACE", "PAUSE", "RESUME", 
		"CREATE_SESSION", "JOIN_SESSION", "REQUEST_SESSIONS", "START_SESSION", 
		"FORWARD", "UP", "NORTH", "BACKWARD", "DOWN", "SOUTH", "LEFT", "WEST", 
		"RIGHT", "EAST", "NUMBER", "MESSAGE"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PlayerCommands.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public PlayerCommandsParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class InputContext : ParserRuleContext {
		public CommandContext command() {
			return GetRuleContext<CommandContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(PlayerCommandsParser.Eof, 0); }
		public InputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_input; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterInput(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitInput(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InputContext input() {
		InputContext _localctx = new InputContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_input);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 18; command();
			State = 19; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StepContext : ParserRuleContext {
		public ITerminalNode NUMBER() { return GetToken(PlayerCommandsParser.NUMBER, 0); }
		public StepContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_step; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterStep(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitStep(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStep(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StepContext step() {
		StepContext _localctx = new StepContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_step);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 21; Match(NUMBER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MessageContext : ParserRuleContext {
		public ITerminalNode MESSAGE() { return GetToken(PlayerCommandsParser.MESSAGE, 0); }
		public MessageContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_message; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterMessage(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitMessage(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMessage(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MessageContext message() {
		MessageContext _localctx = new MessageContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_message);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 23; Match(MESSAGE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandContext : ParserRuleContext {
		public CommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_command; } }
	 
		public CommandContext() { }
		public virtual void CopyFrom(CommandContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DropContext : CommandContext {
		public ITerminalNode DROP() { return GetToken(PlayerCommandsParser.DROP, 0); }
		public DropContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterDrop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitDrop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDrop(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ResumeContext : CommandContext {
		public ITerminalNode RESUME() { return GetToken(PlayerCommandsParser.RESUME, 0); }
		public ResumeContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterResume(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitResume(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResume(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MoveContext : CommandContext {
		public ITerminalNode[] SPACE() { return GetTokens(PlayerCommandsParser.SPACE); }
		public ITerminalNode SPACE(int i) {
			return GetToken(PlayerCommandsParser.SPACE, i);
		}
		public DirectionContext direction() {
			return GetRuleContext<DirectionContext>(0);
		}
		public ITerminalNode MOVE() { return GetToken(PlayerCommandsParser.MOVE, 0); }
		public ITerminalNode WALK() { return GetToken(PlayerCommandsParser.WALK, 0); }
		public ITerminalNode GO() { return GetToken(PlayerCommandsParser.GO, 0); }
		public StepContext step() {
			return GetRuleContext<StepContext>(0);
		}
		public MoveContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterMove(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitMove(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMove(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ReplaceContext : CommandContext {
		public ITerminalNode REPLACE() { return GetToken(PlayerCommandsParser.REPLACE, 0); }
		public ReplaceContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterReplace(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitReplace(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplace(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PickupContext : CommandContext {
		public ITerminalNode PICKUP() { return GetToken(PlayerCommandsParser.PICKUP, 0); }
		public ITerminalNode GET() { return GetToken(PlayerCommandsParser.GET, 0); }
		public PickupContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterPickup(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitPickup(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPickup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class JoinSessionContext : CommandContext {
		public ITerminalNode JOIN_SESSION() { return GetToken(PlayerCommandsParser.JOIN_SESSION, 0); }
		public ITerminalNode SPACE() { return GetToken(PlayerCommandsParser.SPACE, 0); }
		public MessageContext message() {
			return GetRuleContext<MessageContext>(0);
		}
		public JoinSessionContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterJoinSession(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitJoinSession(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitJoinSession(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SayContext : CommandContext {
		public ITerminalNode SAY() { return GetToken(PlayerCommandsParser.SAY, 0); }
		public ITerminalNode SPACE() { return GetToken(PlayerCommandsParser.SPACE, 0); }
		public MessageContext message() {
			return GetRuleContext<MessageContext>(0);
		}
		public SayContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterSay(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitSay(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSay(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CreateSessionContext : CommandContext {
		public ITerminalNode CREATE_SESSION() { return GetToken(PlayerCommandsParser.CREATE_SESSION, 0); }
		public ITerminalNode SPACE() { return GetToken(PlayerCommandsParser.SPACE, 0); }
		public MessageContext message() {
			return GetRuleContext<MessageContext>(0);
		}
		public CreateSessionContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterCreateSession(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitCreateSession(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateSession(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PauseContext : CommandContext {
		public ITerminalNode PAUSE() { return GetToken(PlayerCommandsParser.PAUSE, 0); }
		public PauseContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterPause(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitPause(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPause(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExitContext : CommandContext {
		public ITerminalNode EXIT() { return GetToken(PlayerCommandsParser.EXIT, 0); }
		public ITerminalNode LEAVE() { return GetToken(PlayerCommandsParser.LEAVE, 0); }
		public ExitContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterExit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitExit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExit(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AttackContext : CommandContext {
		public ITerminalNode SPACE() { return GetToken(PlayerCommandsParser.SPACE, 0); }
		public DirectionContext direction() {
			return GetRuleContext<DirectionContext>(0);
		}
		public ITerminalNode ATTACK() { return GetToken(PlayerCommandsParser.ATTACK, 0); }
		public ITerminalNode SLASH() { return GetToken(PlayerCommandsParser.SLASH, 0); }
		public ITerminalNode STRIKE() { return GetToken(PlayerCommandsParser.STRIKE, 0); }
		public AttackContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterAttack(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitAttack(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAttack(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StartSessionContext : CommandContext {
		public ITerminalNode START_SESSION() { return GetToken(PlayerCommandsParser.START_SESSION, 0); }
		public StartSessionContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterStartSession(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitStartSession(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartSession(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShoutContext : CommandContext {
		public ITerminalNode SHOUT() { return GetToken(PlayerCommandsParser.SHOUT, 0); }
		public ITerminalNode SPACE() { return GetToken(PlayerCommandsParser.SPACE, 0); }
		public MessageContext message() {
			return GetRuleContext<MessageContext>(0);
		}
		public ShoutContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterShout(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitShout(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShout(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RequestSessionsContext : CommandContext {
		public ITerminalNode REQUEST_SESSIONS() { return GetToken(PlayerCommandsParser.REQUEST_SESSIONS, 0); }
		public RequestSessionsContext(CommandContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterRequestSessions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitRequestSessions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequestSessions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandContext command() {
		CommandContext _localctx = new CommandContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_command);
		int _la;
		try {
			State = 55;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case MOVE:
			case WALK:
			case GO:
				_localctx = new MoveContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 25;
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MOVE) | (1L << WALK) | (1L << GO))) != 0)) ) {
				_errHandler.RecoverInline(this);
				} else {
					if (_input.La(1) == TokenConstants.Eof) {
						matchedEOF = true;
					}

					_errHandler.ReportMatch(this);
					Consume();
				}
				State = 26; Match(SPACE);
				State = 27; direction();
				State = 30;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if (_la==SPACE) {
					{
					State = 28; Match(SPACE);
					State = 29; step();
					}
				}

				}
				break;
			case ATTACK:
			case SLASH:
			case STRIKE:
				_localctx = new AttackContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 32;
				_la = _input.La(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ATTACK) | (1L << SLASH) | (1L << STRIKE))) != 0)) ) {
				_errHandler.RecoverInline(this);
				} else {
					if (_input.La(1) == TokenConstants.Eof) {
						matchedEOF = true;
					}

					_errHandler.ReportMatch(this);
					Consume();
				}
				State = 33; Match(SPACE);
				State = 34; direction();
				}
				break;
			case PICKUP:
			case GET:
				_localctx = new PickupContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 35;
				_la = _input.La(1);
				if ( !(_la==PICKUP || _la==GET) ) {
				_errHandler.RecoverInline(this);
				} else {
					if (_input.La(1) == TokenConstants.Eof) {
						matchedEOF = true;
					}

					_errHandler.ReportMatch(this);
					Consume();
				}
				}
				break;
			case DROP:
				_localctx = new DropContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 36; Match(DROP);
				}
				break;
			case EXIT:
			case LEAVE:
				_localctx = new ExitContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 37;
				_la = _input.La(1);
				if ( !(_la==EXIT || _la==LEAVE) ) {
				_errHandler.RecoverInline(this);
				} else {
					if (_input.La(1) == TokenConstants.Eof) {
						matchedEOF = true;
					}

					_errHandler.ReportMatch(this);
					Consume();
				}
				}
				break;
			case SAY:
				_localctx = new SayContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 38; Match(SAY);
				State = 39; Match(SPACE);
				State = 40; message();
				}
				break;
			case SHOUT:
				_localctx = new ShoutContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 41; Match(SHOUT);
				State = 42; Match(SPACE);
				State = 43; message();
				}
				break;
			case REPLACE:
				_localctx = new ReplaceContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 44; Match(REPLACE);
				}
				break;
			case PAUSE:
				_localctx = new PauseContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 45; Match(PAUSE);
				}
				break;
			case RESUME:
				_localctx = new ResumeContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 46; Match(RESUME);
				}
				break;
			case CREATE_SESSION:
				_localctx = new CreateSessionContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 47; Match(CREATE_SESSION);
				State = 48; Match(SPACE);
				State = 49; message();
				}
				break;
			case JOIN_SESSION:
				_localctx = new JoinSessionContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 50; Match(JOIN_SESSION);
				State = 51; Match(SPACE);
				State = 52; message();
				}
				break;
			case REQUEST_SESSIONS:
				_localctx = new RequestSessionsContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 53; Match(REQUEST_SESSIONS);
				}
				break;
			case START_SESSION:
				_localctx = new StartSessionContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 54; Match(START_SESSION);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForwardContext : ParserRuleContext {
		public ITerminalNode FORWARD() { return GetToken(PlayerCommandsParser.FORWARD, 0); }
		public ITerminalNode UP() { return GetToken(PlayerCommandsParser.UP, 0); }
		public ITerminalNode NORTH() { return GetToken(PlayerCommandsParser.NORTH, 0); }
		public ForwardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forward; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterForward(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitForward(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForward(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForwardContext forward() {
		ForwardContext _localctx = new ForwardContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_forward);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 57;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << FORWARD) | (1L << UP) | (1L << NORTH))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BackwardContext : ParserRuleContext {
		public ITerminalNode BACKWARD() { return GetToken(PlayerCommandsParser.BACKWARD, 0); }
		public ITerminalNode DOWN() { return GetToken(PlayerCommandsParser.DOWN, 0); }
		public ITerminalNode SOUTH() { return GetToken(PlayerCommandsParser.SOUTH, 0); }
		public BackwardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_backward; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterBackward(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitBackward(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBackward(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BackwardContext backward() {
		BackwardContext _localctx = new BackwardContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_backward);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 59;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BACKWARD) | (1L << DOWN) | (1L << SOUTH))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeftContext : ParserRuleContext {
		public ITerminalNode LEFT() { return GetToken(PlayerCommandsParser.LEFT, 0); }
		public ITerminalNode WEST() { return GetToken(PlayerCommandsParser.WEST, 0); }
		public LeftContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_left; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterLeft(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitLeft(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLeft(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LeftContext left() {
		LeftContext _localctx = new LeftContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_left);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 61;
			_la = _input.La(1);
			if ( !(_la==LEFT || _la==WEST) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RightContext : ParserRuleContext {
		public ITerminalNode RIGHT() { return GetToken(PlayerCommandsParser.RIGHT, 0); }
		public ITerminalNode EAST() { return GetToken(PlayerCommandsParser.EAST, 0); }
		public RightContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_right; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterRight(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitRight(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRight(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RightContext right() {
		RightContext _localctx = new RightContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_right);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 63;
			_la = _input.La(1);
			if ( !(_la==RIGHT || _la==EAST) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectionContext : ParserRuleContext {
		public ForwardContext forward() {
			return GetRuleContext<ForwardContext>(0);
		}
		public BackwardContext backward() {
			return GetRuleContext<BackwardContext>(0);
		}
		public LeftContext left() {
			return GetRuleContext<LeftContext>(0);
		}
		public RightContext right() {
			return GetRuleContext<RightContext>(0);
		}
		public DirectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_direction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.EnterDirection(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPlayerCommandsListener typedListener = listener as IPlayerCommandsListener;
			if (typedListener != null) typedListener.ExitDirection(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPlayerCommandsVisitor<TResult> typedVisitor = visitor as IPlayerCommandsVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirectionContext direction() {
		DirectionContext _localctx = new DirectionContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_direction);
		try {
			State = 69;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case FORWARD:
			case UP:
			case NORTH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 65; forward();
				}
				break;
			case BACKWARD:
			case DOWN:
			case SOUTH:
				EnterOuterAlt(_localctx, 2);
				{
				State = 66; backward();
				}
				break;
			case LEFT:
			case WEST:
				EnterOuterAlt(_localctx, 3);
				{
				State = 67; left();
				}
				break;
			case RIGHT:
			case EAST:
				EnterOuterAlt(_localctx, 4);
				{
				State = 68; right();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3#J\x4\x2\t\x2\x4"+
		"\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4"+
		"\n\t\n\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x3\x5\x5\x5!\n\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x3\x5\x3\x5\x3\x5\x5\x5:\n\x5\x3\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\t"+
		"\x3\t\x3\n\x3\n\x3\n\x3\n\x5\nH\n\n\x3\n\x2\x2\x2\v\x2\x2\x4\x2\x6\x2"+
		"\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x2\n\x3\x2\x4\x6\x3\x2\a\t\x3\x2\n"+
		"\v\x3\x2\r\xE\x3\x2\x18\x1A\x3\x2\x1B\x1D\x3\x2\x1E\x1F\x3\x2 !Q\x2\x14"+
		"\x3\x2\x2\x2\x4\x17\x3\x2\x2\x2\x6\x19\x3\x2\x2\x2\b\x39\x3\x2\x2\x2\n"+
		";\x3\x2\x2\x2\f=\x3\x2\x2\x2\xE?\x3\x2\x2\x2\x10\x41\x3\x2\x2\x2\x12G"+
		"\x3\x2\x2\x2\x14\x15\x5\b\x5\x2\x15\x16\a\x2\x2\x3\x16\x3\x3\x2\x2\x2"+
		"\x17\x18\a\"\x2\x2\x18\x5\x3\x2\x2\x2\x19\x1A\a#\x2\x2\x1A\a\x3\x2\x2"+
		"\x2\x1B\x1C\t\x2\x2\x2\x1C\x1D\a\x3\x2\x2\x1D \x5\x12\n\x2\x1E\x1F\a\x3"+
		"\x2\x2\x1F!\x5\x4\x3\x2 \x1E\x3\x2\x2\x2 !\x3\x2\x2\x2!:\x3\x2\x2\x2\""+
		"#\t\x3\x2\x2#$\a\x3\x2\x2$:\x5\x12\n\x2%:\t\x4\x2\x2&:\a\f\x2\x2\':\t"+
		"\x5\x2\x2()\a\xF\x2\x2)*\a\x3\x2\x2*:\x5\x6\x4\x2+,\a\x10\x2\x2,-\a\x3"+
		"\x2\x2-:\x5\x6\x4\x2.:\a\x11\x2\x2/:\a\x12\x2\x2\x30:\a\x13\x2\x2\x31"+
		"\x32\a\x14\x2\x2\x32\x33\a\x3\x2\x2\x33:\x5\x6\x4\x2\x34\x35\a\x15\x2"+
		"\x2\x35\x36\a\x3\x2\x2\x36:\x5\x6\x4\x2\x37:\a\x16\x2\x2\x38:\a\x17\x2"+
		"\x2\x39\x1B\x3\x2\x2\x2\x39\"\x3\x2\x2\x2\x39%\x3\x2\x2\x2\x39&\x3\x2"+
		"\x2\x2\x39\'\x3\x2\x2\x2\x39(\x3\x2\x2\x2\x39+\x3\x2\x2\x2\x39.\x3\x2"+
		"\x2\x2\x39/\x3\x2\x2\x2\x39\x30\x3\x2\x2\x2\x39\x31\x3\x2\x2\x2\x39\x34"+
		"\x3\x2\x2\x2\x39\x37\x3\x2\x2\x2\x39\x38\x3\x2\x2\x2:\t\x3\x2\x2\x2;<"+
		"\t\x6\x2\x2<\v\x3\x2\x2\x2=>\t\a\x2\x2>\r\x3\x2\x2\x2?@\t\b\x2\x2@\xF"+
		"\x3\x2\x2\x2\x41\x42\t\t\x2\x2\x42\x11\x3\x2\x2\x2\x43H\x5\n\x6\x2\x44"+
		"H\x5\f\a\x2\x45H\x5\xE\b\x2\x46H\x5\x10\t\x2G\x43\x3\x2\x2\x2G\x44\x3"+
		"\x2\x2\x2G\x45\x3\x2\x2\x2G\x46\x3\x2\x2\x2H\x13\x3\x2\x2\x2\x5 \x39G";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace InputHandling.Antlr.Grammar
